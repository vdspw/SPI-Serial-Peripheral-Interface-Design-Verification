Top level description :
1. INPUT -> clk, rst, tx_enable
2. OUTPUT -> mosi(master out slave in) , chip select(cs_), sclk

The operation states:
1. IDLE -> no operation is happening the system is ready for operation.
2. START_TX -> enabled by the active high (tx_enable) signal.
3. TX_DATA -> transaction started.
4. END_TX -> End of transaction.

Use typedef to define the states.
Intitalize the clocking block register -> spi_sclk to 0;Bit count to 0 and counter reg to 0.

the design is dividied as per states and we write the actions of every component :
sclk :(behaviour in all the states) 
1. Generated on the posedge of the clk. 
2. In the IDLE state the spi_clk is 0.
3. In the start_tx state counter value should be 0,1,2,7 for spi+sclk to be high & remaining values its low ( 50 % duty cycle clk).
4. In the Tx_data the logic is same as the above point.
5. end_tx -> when count is less than 3 (clk is high).

reset:
1. If reset is high the state the system is going to be is IDLE.
2. else travels to the next state.

Next State decoder:
1. When any change in the inputs this block gets exected.
2. IDLE state: mosi is 0; chip select is 1 (active low signal),when tx_enabled the state should change.
3. START_Tx state : chip_select is 0 , start_tx to tx_data happens at count 3.
4. Tx_data : put the current bit to the MOSI, do this till the bit_count is 8 .after the bit count crosses 8 reach end_tx.
5. End_tx : chip select becomes 1. mosi (the o/P) becomes zero.

Counter:
1. Operates on the positive edge of the clock.
2. In the IDLE state the count is 0.
3. In the start_tx increment the count by 1.
4. In the tx_data when bit_count is not equal to 8 , and count is less than 7 
increment count by 1. els ecount is 0 and bit_count increments by 1.
5. End_tx : count inceremnt by 1 and bit_count is 0.
